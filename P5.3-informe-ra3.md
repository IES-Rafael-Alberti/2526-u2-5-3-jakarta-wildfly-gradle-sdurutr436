# a) Componentes y funcionamiento de los servicios del servidor

### Contenedor Docker:
Es el entorno aislado que ejecuta WildFly. Usa network namespaces para aislar su red del host y crea un puente virtual (docker0) que conecta el contenedor con la máquina host. Los puertos 8080 y 9990 están mapeados mediante NAT para permitir acceso externo.

### Wildfly Application Server:

Es el servidor de aplicaciones Jakarta EE que actúa como contenedor para tu aplicación. Internamente tiene:
- **Undertow**: El servidor web HTTP que escucha en el puerto 8080 y gestiona las peticiones entrantes.
- **Subsistemas**: CDI (inyección de dependencias), Jakarta REST (JAX-RS), JPA, transacciones, datasources, etc.
- **Deployment Scanner**: Monitoriza y despliega automáticamente los WAR.

### Archivo WAR:

Es el artefacto desplegable que contiene:
- Clases compiladas: la definición de la ruta base para REST, y el recurso que expone el CRUD. `Task.java` es el modelo de datos. El resto son archivos para que las tareas funcionen.
- Descriptores: `jboss-web.xml` define el contexto para personalizar la URL base, sin tener que modificar como se llama el archivo `.war`.
- Dependencias: Jakarta EE 10 API con Wildfly.

### Puertos:

**8080**: Puerto desde el que se escuchan las peticiones de la aplicación. Es el punto de entrada mapeado con Docker.

**9990**: Puerto donde se expone la consola de administración. Me permite configurar todo, monitorizar métricas y gestionar despliegues. También me permite modificar `standalone.xml` con advertencias por si hago algo mal.

### Endpoint REST (/api/tasks):

Es el rescurso Java de `TaskResource.java` cuyo `@Path("/tasks")` es el punto de partida. Todo se mapea a partir de aquí:
- `GET /api/tasks`: devuelve un JSON con todas las tareas.
- `GET /api/tasks/{id}`: devuelve la tarea con ese id o 404.
- `POST /api/tasks`: crea una nueva tarea. Necesario el titulo.
- `PUT /api/tasks/{id}`: actualiza una tarea existente.
- `DELETE /api/tasks/{id}`: elimina tarea por ID.

Las anotaciones que hay en el código indican que se trabaja con JSON.

---

## Flujo de usuario:

1. Cliente inicia la petición
2. Se procesa la petición y se manda al puerto 8080
3. Docker Desktop intercepta el tráfico, creando una red virtual. Wildfly tiene una IP asignada y se redirigen a ese contenedor.
4. Undertow recibe la conexión y parsea la petición HTTP.
5. Wildly busca el routing correcto por el contexto y la delega.
6. Jakarta REST analiza la ruta y procesa según la configuración.
7. Se crea una instancia de `TaskResource` si todo ha ido bien.
8. Se ejecuta la lógica de negocio, añadiendo la tarea a la lista (en caso de que sea añadir una por ejemplo).
9. Serialización de la respuesta: la `List<Task>` a JSON.
10. Construccion de la respuesta HTTP.
11. Docker Desktop reenvia la respuesta de forma inversa.
12. Cliente recibe y procesa mostrando el JSON.

---

## Evidencias parte a):

Contenedores y puertos publicados del contenedor Wildfly:

![Contenedor wildly](img/01-contenedor-docker-corriendo.png)

Despliegue y acceso del contenedor (sus logs):

![Logs de wildfly](img/04-logs-wildfly.png)

Respuesta del endpoit (previamente poblado porque esta vacio):

![Curl al endpoint de tasks](img/06-curl-3-tareas.png)

---

# b) Archivos principales de configuración y bibliotecas compartidas

La ruta del archivo de configuración:

```bash
docker exec -it wildfly ls -lh /opt/jboss/wildfly/standalone/configuration/
```

El comando me muestra:

![Archivos de configuracion Wildfly](img/09-archivo-de-configuracion-localizado.png)

Se podría tocar la configuración de **Datasources** que es donde configuro mi conexión a una base de datos, por ejemplo MySQL, para guardar las tareas en una base de datos en lugar de un JSON gigante.

También para cambiar los puertos e interfaces red para utilizar otros puertos y ajustar la ruta donde se guardan los logs.

---

La práctica pide que use ``build.gradle.kts`` de la práctica 5.2, pero en el repositorio del 5.3 no hay y hay un ``build.gradle`` que está teniendo prioridad sobre el ``.kts``. He recuperado y modificado el ``.kts`` y renombrado a ``old`` el otro para que se use el que pide la práctica.

```bash
dependencies {
    compileOnly("jakarta.platform:jakarta.jakartaee-api:10.0.0")

    testImplementation("org.junit.jupiter:junit-jupiter:5.10.2")
}
```

Evidencia:

![Salida completa](img/10-salida-nuevo-5.3.png)

# c) Cooperación con el servidor web (proxy / reverse proxy) y https

La arquitectura que propongo es:

Internet (a través del puerto 443 HTTPS) -> Nginx (mi contenedor alpine) -> Wildfly (puerto interno 8080, que no está expuesto).

